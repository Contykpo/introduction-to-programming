// Ejercicio 1: Sorting

Competidor = struct<nombre: string, puntos: nat, intentos: nat>

TablaKPosiciones(in competidores: Array<Competidor>, in k: nat): Secuencia<string>
{
    puntajesCompetidores : DiccionarioDigital<> = new DiccionarioDigital<puntos: nat, ListaEnlazada(struct<intentos: nat, posicion: nat>)>(); // O(n)

    for (int i = 0; i < competidores.tamaño(); i++) //O(n + k)
    {
        if(competidores[i].puntos in puntajesCompetidores)
        {
            for (int j = 0; j < puntajesCompetidores.obtener(competidores[i].puntos).tamaño(); j++)
            {
                if (puntajesCompetidores.obtener(competidores[i].puntos).encontrar(j).intentos < competidores[i].intentos)
                {
                    puntajesCompetidores.obtener(competidores[i].puntos).encontrar(j).intentos = competidores[i].intentos;
                    puntajesCompetidores.obtener(competidores[i].puntos).encontrar(j).posicion = i;
                }
                else
                {
                    puntajesCompetidores.definir(competidores[i].puntos, puntajesCompetidores.obtener(competidores[i].puntos).agregar(<intentos: competidores[i].intentos, posicion: i>)); // O(k)
                }
            }
        }
        else
        {
            listaCompetidores : ListaEnlazada = listaCompetidores.listaVacia();
            listaCompetidores.agregar(<intentos: competidores[i].intentos, posicion: i>) 
            puntajesCompetidores.definir(competidores[i].puntos, listaCompetidores);
        }
    }

    temporalMaximos: Array<Competidor> := new Array<Competidor>[a.length]; //O(n)

    for (int i = 0; i < competidores.tamaño(); i++) //O(n)
    {
        temporalMaximos[i].nombre := competidores[i].nombre;
        temporalMaximos[i].intentos := competidores[i].intentos;
        temporalMaximos[i].posicion := competidores[i].puntaje;
    }

    maxHeapCompetidor := HeapifyMax(temporal); //O(n), Algoritmo de Floyd

    tablakCompetidores: Array<Competidor> := new Array<Competidor>[k]; //O(k)
    indexT : nat = 0;

    for (int i = 0; i < k && indexT < k; i++) //O(n) // O(k * log n + k) = O(k * log n) 
    {
        liderPuntaje : Competidor = maxHeapCompetidor.pop(); // O(log n)
        iterador : IteradorBidireccional = puntajesCompetidores[liderPuntaje.puntaje].iterador(); // O(1)
        while iterador.haySiguiente() // O(k)
        {
            tablakCompetidores[indexT] = competidores[iterador.siguiente().posicion] ;
            iterador.siguiente()indexT++;
        }
    }

    //Total: O(n + k * log n)
    return tablakCompetidores;
}
